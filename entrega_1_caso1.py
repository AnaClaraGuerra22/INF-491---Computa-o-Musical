# -*- coding: utf-8 -*-
"""Entrega 1 - Caso1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zNLFoOsZwfUxXKTne2cHkUKBUiS9t636

# CASO 1 - Toninho vs. Adele

original: mulheres, de Toninho

acusada: Million Years Ago, de Adele


A- MELODIA

Alegação: A alegação envolvia a melodia principal do refrão e também a
progressão harmônica subjacente

## Carregamento .mp3
"""

from google.colab import files
import librosa
import librosa.display
import matplotlib.pyplot as plt
import librosa.util
import numpy as np
from scipy.signal import resample
from librosa.sequence import dtw

# Upload dos arquivos .mp3
print("Faça upload de dois arquivos .mp3 (original e acusado):")
uploaded = files.upload()

# Listar os arquivos carregados
file_names = list(uploaded.keys())
if len(file_names) != 2:
    raise ValueError("Você deve carregar exatamente dois arquivos.")

print("\nArquivos enviados:")
for i, name in enumerate(file_names):
    print(f"{i+1}: {name}")

# Solicita ao usuário que diga qual é o original
print("\nDigite exatamente o nome do arquivo que corresponde à OBRA ORIGINAL:")
nome_original = input().strip()

if nome_original not in file_names:
    raise ValueError("Nome inválido! Certifique-se de digitar exatamente como aparece acima.")

# Determina quem é o acusado
file_original = nome_original
file_acusado = [f for f in file_names if f != nome_original][0]
print(f"\nEntão o acusado é:\n{file_acusado}")

"""# Cromagramas"""

# Carregar os áudios
y_orig, sr_orig = librosa.load(file_original, sr=None)
y_acus, sr_acus = librosa.load(file_acusado, sr=None)

# Gerar cromagramas
chroma_orig = librosa.feature.chroma_cqt(y=y_orig, sr=sr_orig)
chroma_acus = librosa.feature.chroma_cqt(y=y_acus, sr=sr_acus)

#função para imprimir cromagramas lado a lado


def plot_cromagramas_lado_a_lado(chroma1, chroma2, sr1, sr2, title1, title2, suptitle):
    fig, axs = plt.subplots(1, 2, figsize=(16, 4), sharey=True)

    # Supertítulo seguro (com espaço reservado)
    fig.suptitle(suptitle, fontsize=16)

    # Cromagrama 1
    img1 = librosa.display.specshow(chroma1, y_axis='chroma', x_axis='time', sr=sr1, ax=axs[0])
    axs[0].set_title(title1)
    fig.colorbar(img1, ax=axs[0])

    # Cromagrama 2
    img2 = librosa.display.specshow(chroma2, y_axis='chroma', x_axis='time', sr=sr2, ax=axs[1])
    axs[1].set_title(title2)
    fig.colorbar(img2, ax=axs[1])

    # Ajusta espaço para o título
    plt.tight_layout(rect=[0, 0, 1, 0.93])
    plt.show()

plot_cromagramas_lado_a_lado(
    chroma_orig, chroma_acus,
    sr_orig, sr_acus,
    f'Obra Original: {file_original}',
    f'Obra Acusada: {file_acusado}',
    'Cromagramas'
)

''' # Plot - original
plt.figure(figsize=(10, 4))
librosa.display.specshow(chroma_orig, y_axis='chroma', x_axis='time', sr=sr_orig)
plt.title(f'Cromagrama - Obra ORIGINAL: {file_original}')
plt.colorbar()
plt.tight_layout()
plt.show()


# Plot - acusado
plt.figure(figsize=(10, 4))
librosa.display.specshow(chroma_acus, y_axis='chroma', x_axis='time', sr=sr_acus)
plt.title(f'Cromagrama - Obra ACUSADA: {file_acusado}')
plt.colorbar()
plt.tight_layout()
plt.show()
'''

"""#Analise de Melodia

## 1.Compressao Logaritmica - Sincronização

A compressão logarítmica ajuda a reduzir a variação de intensidade entre os vetores cromáticos antes de comparar

Redução de picos extremos, mais equilíbrio na visualização
"""

def log_compression(S, factor=10000):
    return np.log1p(factor * S)

chroma_orig_log = log_compression(chroma_orig)
chroma_acus_log = log_compression(chroma_acus)


plot_cromagramas_lado_a_lado(
    chroma_orig, chroma_acus,
    sr_orig, sr_acus,
    f'Obra Original - {file_original}',
    f'Obra Acusada - {file_acusado}',
    'Compressão Logaritmica'

)

"""## 2. Transposição para a tônica C - Sincronização

Transpor os cromagramas de ambas as músicas para que comecem na mesma tônica evita distorções na similaridade melódica



As “faixas” melódicas mudam de lugar, mas mantém a forma do contorno
"""

def transpose_to_C(chroma):
    mean_vector = chroma.mean(axis=1)
    shift = np.argmax(mean_vector)
    return np.roll(chroma, -shift, axis=0)

chroma_orig_transposed = transpose_to_C(chroma_orig_log)
chroma_acus_transposed = transpose_to_C(chroma_acus_log)

plot_cromagramas_lado_a_lado(
    chroma_orig_transposed, chroma_acus_transposed,
    sr_orig, sr_acus,
    f'Obra Original: {file_original}',
    f'Obra Acusada: {file_acusado}',
    'Transposição para C'
)

"""## 3.  Sincronização com DTW

Usar o Dynamic Time Warping com métrica de similaridade (cosseno) entre os cromagramas transpostos


Alinhamento visual, custo final e variação temporal
"""

# Evitar que diferenças de volume influenciem a DTW.

chroma_orig_transposed = librosa.util.normalize(chroma_orig.T).T
chroma_acus_transposed = librosa.util.normalize(chroma_acus.T).T

# reduzir dados para 1000 frames

target_frames = 1000

chroma_orig_ds = resample(chroma_orig_transposed, target_frames, axis=1)
chroma_acus_ds = resample(chroma_acus_transposed, target_frames, axis=1)

# DTW com metrica Cosseno
D, wp = dtw(X=chroma_orig_ds, Y=chroma_acus_ds, metric='cosine')

# Visualizar a matriz de custo acumulado com o caminho ótimo
plt.figure(figsize=(8, 8))
librosa.display.specshow(D, x_axis='time', y_axis='time')
plt.plot(wp[:, 1], wp[:, 0], color='yellow')
plt.title('DTW - Alinhamento (resample aplicado)')
plt.colorbar()
plt.show()

# Imprimir a distância DTW total (custo do caminho ótimo)
dist_total = D[wp[-1, 0], wp[-1, 1]]
print(f"Distância DTW total: {dist_total:.2f}")

D_test, wp_test = dtw(X=chroma_orig_ds[:, :100], Y=chroma_acus_ds[:, :100], metric='cosine')
print("Distância DTW parcial (100 frames):", D_test[wp_test[-1, 0], wp_test[-1, 1]])


# Visualizar a matriz de custo acumulado com o caminho ótimo
plt.figure(figsize=(8, 8))
librosa.display.specshow(D_test, x_axis='time', y_axis='time')
plt.plot(wp_test[:, 1], wp_test[:, 0], color='yellow')
plt.title('DTW parcial - 100 frames')
plt.colorbar()
plt.show()


dist_parcial = D_test[wp_test[-1, 0], wp_test[-1, 1]]
#print(f"Distância DTW total: {dist_parcial:}")


dist_parcial_media = dist_parcial / len(wp_test)
print(f"Distância DTW média (100 frames): {dist_parcial_media:.4f}")

# Ajuste o tamanho conforme necessário para análise prática
segmento = 200  # ou 300, 500 etc.

D_seg, wp_seg = dtw(X=chroma_orig_ds[:, :segmento], Y=chroma_acus_ds[:, :segmento], metric='cosine')
plt.figure(figsize=(8, 8))
librosa.display.specshow(D_seg, x_axis='time', y_axis='time')
plt.plot(wp_seg[:, 1], wp_seg[:, 0], color='yellow')
plt.title(f'DTW - {segmento} frames iniciais')
plt.colorbar()
plt.show()

print(f"Distância DTW ({segmento} frames): {D_seg[wp_seg[-1, 0], wp_seg[-1, 1]]:.4f}")